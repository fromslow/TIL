## 1강. 데이터베이스
DBMS는 **데이터베이스를 관리하는 소프트웨어**로, 사용 목적은 **생산성 향상과 기능성, 신뢰성 확보**에 있음
- 생산성: DBMS가 데이터 검색, 추가, 삭제, 갱신과 같은 기본 기능을 제공
- 기능성: 복수 유저의 요청에 대응하거나 대용량의 데이터를 저장하고, 고속으로 검색하는 기능을 제공
- 신뢰성: 많은 요청에 대응 가능하도록 만들어져 있음. 일부는 컴퓨터 여러 대를 두고, 소프트웨어를 통해 확장성과 부하 분산을 구현. 이를 클러스터 구성 또는 스케일 아웃이라고 부름. 

## 2강. 다양한 데이터베이스
1. 계층형 데이터베이스
2. 관계형 데이터베이스: **관계대수**에서 착안하여 고안한 데이터베이스. 표 형식 데이터를 저장하는 형태의 데이터 베이스
3. 객체지향 데이터베이스: ‘가능하면 객체 그대로의 데이터베이스를 데이터로 저장하는 것’
4. XML 데이터베이스
5. KVS(키-밸류 스토어)

## 3강. 데이터베이스 서버
많은 RDBMS가 클라이언트/서버 모델을 채택에 가동 중

## 4강. Hello World 실행하기
- 예약어와 데이터베이스 객체명은 대소문자를 구분하지 않음
- 데이터는 자료형으로 분류 가능
- 열은 하나의 자료형만 가질 수 있음

## 5강. 테이블 구조 참조하기
- INTEGER
- CHAR: 고정 길이 문자열
- VARCHAR: 가변 길이 문자열
- DATE
- TIME

## 6강. 검색 조건 지정하기
행을 선택할 때는 WHERE 구를 사용하며, 열을 선택할 때는 SELECT 구를 사용

## 7강. 조건 조합하기
- AND는 OR에 비해 우선 순위가 높음

## 8강. 패턴 매칭에 의한 검색
- LIKE 술어를 사용하여 패턴 매칭으로 검색 가능
- 패턴을 정의할 때 사용할 수 있는 메타문자로는 %와 _가 있음
- LIKE로 %나 _를 검색하기 위해서는 ‘\%’, ‘\_’와 같이 \를 앞에 붙임
- ‘의 이스케이프 : It’s > ‘It’’s’, ‘ > ‘’’’

## 9강. 정렬 - ORDER BY
검색 결과의 행 순서를 변경 가능

## 10강. 복수의 열을 지정해 정렬하기
ORDER BY 구를 사용하지 않을 시, 같은 값을 가진 행의 순서는 데이터베이스 서버의 당시 상황에 따라 어떤 순서로 행을 반환할지 결정함. 따라서, 언제나 같은 순서로 결과를 얻고 싶다면 반드시 ORDER BY 구로 순서를 지정해야 함.

## 11강. 결과 행 제한하기 - LIMIT
SELECT 열명 FROM 테이블명 LIMIT 행수 OFFSET 위치

## 12강. 수치 연산
- 이름에 ASCII 문자 이외의 것을 포함할 경우 더블쿼트로 둘러싸서 지정
- 더블쿼트로 둘러싸면 명령 구문을 분석할 때 데이터베이스 객체의 이름이라고 간주하며, 싱글쿼트로 둘러싸면 문자열 상수라고 간주함
- WHERE 구 > SELECT 구 순서로 처리. 이에 따라 SELECT 구에서 지정한 별명은 WHERE 구 안에서 사용 불가
- ORDER BY는 서버에서 가장 나중에 처리되므로 SELECT에서 사용한 별명을 ORDER BY에서도 사용 가능

## 13강. 문자열 연산
- CHAR_LENGTH: 문자열 길이를 계산해 돌려주는 함수
- OCTET_LENGTH: 문자열의 길이를 바이트 단위로 계산해 돌려주는 함수
- 문자열 데이터의 길이는 문자세트에 따라 달라짐(문자세트별로 바이트 계산 기준이 다르기 때문)

## 14강. 날짜 연산
- 날짜 데이터는 서식 지정 가능

## 15강. CASE 문으로 데이터 변환하기
- COALESCE:  주어진 인수 가운데 NULL이 아닌 값에 대해서는 가장 먼저 지정된 인수의 값을 반환하고, NULL 값은 두번 째 지정된 인수의 값을 반환함
- 검색 CASE 문
![](https://velog.velcdn.com/images/numver_se/post/4a7753e6-a0c0-4833-aa9e-6ae097f519eb/image.png)
- 단순 CASE 문
![](https://velog.velcdn.com/images/numver_se/post/eb23a1ec-f127-49c8-8632-780670fb0275/image.png)
- 단순 CASE 문은 특성상 = 연산자로만 비교 가능하여 NULL 값이 비교 불가능함
- CASE 문에서 ELSE를 생략할 경우, ELSE NULL이 됨. ELSE를 생략하면 상정한 것 이외의 데이터가 왔을 때 NULL이 반환되므로 ELSE를 생략하지 않고 지정하는 편이 나음

## 16강. 행 추가하기 - INSERT
INSERT INTO 테이블명 VALUES (값1, 값2, …)

## 17강. 삭제하기 - DELETE
DELETE FROM 테이블명 WHERE 조건식

## 18. 데이터 갱신하기 - UPDATE
UPDATE 테이블명 SET 열1 = 값1, 열2 = 값2, … WHERE 조건식
- ORACLE에서는 SET 구에 기술한 식의 순서가 처리에 영향을 주지 않지만, MySQL에서는 SET 구에 기술된 순서로 갱신 처리가 일어나므로 MySQL의 경우, 갱신식 안에서 열을 참조할 때는 처리 순서를 고려할 필요가 있음

## 19강. 물리삭제와 논리삭제
- 물리삭제: SQL의 DELETE 명령을 사용해 직접 데이터를 삭제하자는 사고방식
- 논리삭제: 테이블에서 실제로 행을 삭제하는 대신, UPDATE 명령을 이용해 ‘삭제플래그’의 값을 유효하게 갱신해두자는 발상에 의한 삭제방법
